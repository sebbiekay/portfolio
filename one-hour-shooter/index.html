<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>One Hour Shooter - Web</title>
    <style>
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #050505;
        font-family: "Nunito", "Segoe UI", sans-serif;
        color: #ffffff;
      }

      #game-canvas {
        border: 2px solid #3f3f3f;
        image-rendering: pixelated;
        max-width: 90vw;
        max-height: 90vh;
      }

      #loading {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <div id="loading">Loading assets…</div>
    <canvas id="game-canvas" width="800" height="600"></canvas>

    <script type="module">
      import { loadPyodide } from "https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.mjs";

      const assetManifest = {
        bg: "1hrfps_assets/bg.png",
        player: "1hrfps_assets/player.png",
        bullet: "1hrfps_assets/bullet.png",
        enemy: "1hrfps_assets/enemy.png",
      };

      function loadAssets(manifest) {
        const entries = Object.entries(manifest);
        const assets = {};
        return Promise.all(
          entries.map(
            ([key, src]) =>
              new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => {
                  assets[key] = image;
                  resolve();
                };
                image.onerror = reject;
                image.src = src;
              })
          )
        ).then(() => assets);
      }

      const FALLBACK_GAME_SOURCE = `import random
from js import document, window
from pyodide.ffi import create_proxy

CANVAS_ID = globals().get("CANVAS_ID", "game-canvas")
canvas = document.getElementById(CANVAS_ID)
ctx = canvas.getContext("2d")
assets = window.assetImages

SCREEN_WIDTH = canvas.width
SCREEN_HEIGHT = canvas.height

PLAYER_WIDTH = 50
PLAYER_HEIGHT = 60
PLAYER_SPEED = 5  # pixels per frame in desktop build
STARTING_LIVES = 3

BULLET_WIDTH = 10
BULLET_HEIGHT = 20
BULLET_SPEED = 7

ENEMY_WIDTH = 50
ENEMY_HEIGHT = 60
ENEMY_SPEED = 2
ENEMY_SPAWN_INTERVAL = 2.0

HIT_REWARD = 100
COLLISION_PENALTY = 50

pressed_keys = set()
key_down_proxy = None
key_up_proxy = None
loop_proxy = None

player = {}
bullets = []
enemies = []
score = 0
lives = STARTING_LIVES
game_over = False
game_over_message = "Game Over"
enemy_timer = 0.0
last_timestamp = None


def reset_game():
    global player, bullets, enemies, score, lives, game_over, enemy_timer, last_timestamp, game_over_message
    player = {
        "x": SCREEN_WIDTH / 2 - PLAYER_WIDTH / 2,
        "y": SCREEN_HEIGHT - PLAYER_HEIGHT - 10,
        "w": PLAYER_WIDTH,
        "h": PLAYER_HEIGHT,
    }
    bullets = []
    enemies = []
    score = 0
    lives = STARTING_LIVES
    game_over = False
    game_over_message = "Game Over"
    enemy_timer = 0.0
    last_timestamp = None


def spawn_bullet():
    if game_over:
        return
    bullet = {
        "x": player["x"] + (PLAYER_WIDTH - BULLET_WIDTH) / 2,
        "y": player["y"] - 5,
        "w": BULLET_WIDTH,
        "h": BULLET_HEIGHT,
    }
    bullets.append(bullet)


def spawn_enemy():
    enemy_x = random.randint(0, SCREEN_WIDTH - ENEMY_WIDTH)
    enemy = {"x": enemy_x, "y": -ENEMY_HEIGHT, "w": ENEMY_WIDTH, "h": ENEMY_HEIGHT}
    enemies.append(enemy)


def clamp(value, min_value, max_value):
    return max(min_value, min(value, max_value))


def rectangles_overlap(a, b):
    return (
        a["x"] < b["x"] + b["w"]
        and a["x"] + a["w"] > b["x"]
        and a["y"] < b["y"] + b["h"]
        and a["y"] + a["h"] > b["y"]
    )


def trigger_game_over(message):
    global game_over, game_over_message
    game_over = True
    game_over_message = message


def on_keydown(event):
    key = event.code
    pressed_keys.add(key)
    if key in {"ArrowLeft", "ArrowRight", "KeyA", "KeyD", "Space"}:
        event.preventDefault()

    if key == "Space":
        spawn_bullet()
    elif key == "KeyR" and game_over:
        reset_game()
    elif key == "KeyQ":
        trigger_game_over("Quit")


def on_keyup(event):
    key = event.code
    pressed_keys.discard(key)
    if key in {"ArrowLeft", "ArrowRight", "KeyA", "KeyD", "Space"}:
        event.preventDefault()


def update_state(delta_seconds):
    global enemy_timer, lives, score
    if game_over:
        return

    frame_scale = delta_seconds * 60.0
    move_direction = 0
    if "ArrowLeft" in pressed_keys or "KeyA" in pressed_keys:
        move_direction -= 1
    if "ArrowRight" in pressed_keys or "KeyD" in pressed_keys:
        move_direction += 1
    player["x"] += move_direction * PLAYER_SPEED * frame_scale
    player["x"] = clamp(player["x"], 0, SCREEN_WIDTH - PLAYER_WIDTH)

    for bullet in bullets[:]:
        bullet["y"] -= BULLET_SPEED * frame_scale
        if bullet["y"] + BULLET_HEIGHT < 0:
            bullets.remove(bullet)

    enemy_timer += delta_seconds
    if enemy_timer >= ENEMY_SPAWN_INTERVAL:
        spawn_enemy()
        enemy_timer = 0.0

    for enemy in enemies[:]:
        enemy["y"] += ENEMY_SPEED * frame_scale
        if enemy["y"] > SCREEN_HEIGHT:
            enemies.remove(enemy)

    for bullet in bullets[:]:
        bullet_rect = bullet
        for enemy in enemies[:]:
            if rectangles_overlap(bullet_rect, enemy):
                bullets.remove(bullet_rect)
                enemies.remove(enemy)
                score += HIT_REWARD
                break

    for enemy in enemies[:]:
        if rectangles_overlap(enemy, player):
            enemies.remove(enemy)
            score = max(0, score - COLLISION_PENALTY)
            lives -= 1
            if lives <= 0:
                trigger_game_over("Game Over")
            break


def draw_scene():
    ctx.drawImage(assets.bg, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
    ctx.drawImage(assets.player, player["x"], player["y"], PLAYER_WIDTH, PLAYER_HEIGHT)

    for bullet in bullets:
        ctx.drawImage(assets.bullet, bullet["x"], bullet["y"], BULLET_WIDTH, BULLET_HEIGHT)

    for enemy in enemies:
        ctx.save()
        ctx.translate(enemy["x"] + ENEMY_WIDTH / 2, enemy["y"] + ENEMY_HEIGHT / 2)
        ctx.scale(1, -1)
        ctx.drawImage(
            assets.enemy,
            -ENEMY_WIDTH / 2,
            -ENEMY_HEIGHT / 2,
            ENEMY_WIDTH,
            ENEMY_HEIGHT,
        )
        ctx.restore()

    ctx.fillStyle = "#ffffff"
    ctx.font = "20px 'Nunito', sans-serif"
    ctx.textAlign = "left"
    ctx.fillText(f"Score: {score}", 10, 24)
    ctx.fillText(f"Lives: {lives}", 10, 48)

    control_lines = [
        "Move: A/D or Arrow Keys",
        "Shoot: Space",
        "Quit: Q  |  Restart: R",
    ]
    for index, line in enumerate(control_lines):
        ctx.fillText(line, 10, 80 + index * 22)

    if game_over:
        ctx.fillStyle = "rgba(0, 0, 0, 0.65)"
        ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
        ctx.fillStyle = "#ffffff"
        ctx.textAlign = "center"
        ctx.font = "48px 'Nunito', sans-serif"
        ctx.fillText(game_over_message, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 40)
        ctx.font = "24px 'Nunito', sans-serif"
        ctx.fillText(f"Final Score: {score}", SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
        ctx.fillText("Press R to Restart", SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 36)
        ctx.textAlign = "left"


def game_loop(timestamp):
    global last_timestamp
    if last_timestamp is None:
        last_timestamp = timestamp
    delta_seconds = (timestamp - last_timestamp) / 1000.0
    last_timestamp = timestamp
    update_state(delta_seconds)
    draw_scene()
    window.requestAnimationFrame(loop_proxy)


def init():
    global key_down_proxy, key_up_proxy, loop_proxy
    reset_game()
    key_down_proxy = create_proxy(on_keydown)
    key_up_proxy = create_proxy(on_keyup)
    document.addEventListener("keydown", key_down_proxy)
    document.addEventListener("keyup", key_up_proxy)
    loop_proxy = create_proxy(game_loop)
    window.requestAnimationFrame(loop_proxy)


init()
`;

      async function loadGameSource() {
        const url = new URL("./web_game.py", window.location.href);
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return await response.text();
        } catch (error) {
          console.warn("Falling back to bundled web_game.py", error);
          return FALLBACK_GAME_SOURCE;
        }
      }

      async function main() {
        const loading = document.getElementById("loading");
        loading.textContent = "Booting Pyodide…";
        const pyodide = await loadPyodide();
        loading.textContent = "Fetching assets…";
        const [assets, gameSource] = await Promise.all([
          loadAssets(assetManifest),
          loadGameSource(),
        ]);
        window.assetImages = assets;
        pyodide.globals.set("CANVAS_ID", "game-canvas");
        loading.textContent = "Starting game…";
        await pyodide.runPythonAsync(gameSource);
        loading.remove();
      }

      main().catch((error) => {
        console.error(error);
        alert("Failed to start game. Check the console for details.");
      });
    </script>
  </body>
</html>
